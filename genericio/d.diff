diff --git a/DataGenerator/dataGen.cpp b/DataGenerator/dataGen.cpp
index 3587b57..42334ed 100755
--- a/DataGenerator/dataGen.cpp
+++ b/DataGenerator/dataGen.cpp
@@ -155,7 +155,7 @@ int main(int argc, char* argv[])
 		newGIO.addVariable("id", id, GenericIO::VarHasExtraSpace);
 		newGIO.addVariable("mask", mask, GenericIO::VarHasExtraSpace);
 
-		newGIO.useOctree(true, 2, true);
+		newGIO.useOctree(3);	// num levels, shuffle true by default
         newGIO.write();
 
 		MPI_Barrier(MPI_COMM_WORLD);
@@ -172,4 +172,5 @@ int main(int argc, char* argv[])
 	return 0;
 }
 
+// ./compile.sh
 // mpirun -np 8 ./dataGen outputFile
\ No newline at end of file
diff --git a/DataGenerator/dataGenNoOct.cpp b/DataGenerator/dataGenNoOct.cpp
index 7ce22ce..afb68d5 100644
--- a/DataGenerator/dataGenNoOct.cpp
+++ b/DataGenerator/dataGenNoOct.cpp
@@ -29,15 +29,15 @@ int main(int argc, char* argv[])
 	
 	{
 		float simExtents[6]={0,256, 0,256, 0,256};
-		int dims[3]= {2, 2, 2};		// 8
-		//int dims[3]= {4, 4, 2};		// 32
-		int periods[3] = { 0, 0, 0 };
+		
 		int physOrigin[3] = {0, 0, 0};
 		int physScale[3] = {256, 256, 256};
 		size_t numParticles = 10000;
 
-
-		MPI_Cart_create(Comm, 3, dims, periods, 0, &Comm);
+		//int dims[3]= {2, 2, 2};		// 8
+		//int dims[3]= {4, 4, 2};		// 32
+		//int periods[3] = { 0, 0, 0 };
+		//MPI_Cart_create(Comm, 3, dims, periods, 0, &Comm);
 		
 		unsigned method = GenericIO::FileIOMPI;
 
diff --git a/genericio/GNUmakefile b/genericio/GNUmakefile
index 6f0b0dd..3a6f053 100644
--- a/genericio/GNUmakefile
+++ b/genericio/GNUmakefile
@@ -59,7 +59,7 @@ BLOSC_CPPFLAGS := \
 	-Ithirdparty/blosc/internal-complibs/zstd-0.7.4/dictBuilder \
 	-Ithirdparty/blosc/internal-complibs/zstd-0.7.4/decompress
 
-BASE_CPPFLAGS := $(BLOSC_CPPFLAGS) -I. -D__STDC_CONSTANT_MACROS -DDEBUG_ON -std=c++11
+BASE_CPPFLAGS := $(BLOSC_CPPFLAGS) -I. -D__STDC_CONSTANT_MACROS -DDEBUG_ON
 #BASE_CPPFLAGS := $(BLOSC_CPPFLAGS) -I. -D__STDC_CONSTANT_MACROS
 
 FEDIR = frontend
diff --git a/genericio/GenericIO.cxx b/genericio/GenericIO.cxx
index d0c8cf1..f64c50e 100644
--- a/genericio/GenericIO.cxx
+++ b/genericio/GenericIO.cxx
@@ -409,6 +409,7 @@ void GenericIO::write()
         write<false>();
 }
 
+
 // Note: writing errors are not currently recoverable (one rank may fail
 // while the others don't).
 template <bool IsBigEndian>
@@ -590,6 +591,7 @@ void GenericIO::write()
 
         size_t numParticles = NElems;
 
+
         //
         // MPI Rank 
         int myRank = Rank;
@@ -617,15 +619,20 @@ void GenericIO::write()
         //
         // Create octree structure
         Octree gioOctree;
-        if (simGlobalOctree)
-            gioOctree.init(numOctreeLevels, simExtents);
-        else
-            gioOctree.init(numOctreeLevels, myRankExtents);
+        gioOctree.myRank = myRank;
 
-        gioOctree.setRankExtents(myRankExtents);
+        std::cout << "$$$$$$Dims: " << Dims[0] << ", " << Dims[1] << ", " << Dims[2] << std::endl;
+        std::cout << "!!!!!!!myRankExtents: " << myRankExtents[0] << "-" << myRankExtents[1] << "," 
+                                                  << myRankExtents[2] << "-" << myRankExtents[3] << "," 
+                                                  << myRankExtents[4] << "-" << myRankExtents[5] << std::endl;
 
+        // Create Octree
+        gioOctree.init(numOctreeLevels, simExtents, Dims[0], Dims[1], Dims[2]); // num octree levels, sim extent, sim decompisition
         gioOctree.buildOctree();
-        gioOctree.myRank = myRank;
+
+
+        //gioOctree.setRankExtents(myRankExtents);
+
         int numOctreeLeaves = gioOctree.getNumNodes();
 
       #ifdef DEBUG_ON
@@ -639,19 +646,24 @@ void GenericIO::write()
         log << "|After build octree: " << ongoingMem.getMemoryInUseInMB() << " MB " << std::endl;
       #endif
 
+    
+
         //
         // Find partitions for myRank
-        std::set< int > myLeaves;
-        for (int l=0; l<numOctreeLeaves; l++)
-        {
-            float leafExtents[6];
-            gioOctree.getLeafExtents(l, leafExtents);
+        std::vector< int > myLeaves = gioOctree.getLeaves(myRank);
+        int numleavesForMyRank = myLeaves.size();
 
-            if ( gioOctree.checkOverlap(leafExtents, myRankExtents) )
-                myLeaves.insert(l);
-        }
+        // std::set< int > myLeaves;
+        // for (int l=0; l<numOctreeLeaves; l++)
+        // {
+        //     float leafExtents[6];
+        //     gioOctree.getLeafExtents(l, leafExtents);
 
-        int numleavesForMyRank = myLeaves.size();
+        //     if ( gioOctree.checkOverlap(leafExtents, myRankExtents) )
+        //         myLeaves.insert(l);
+        // }
+
+        // int numleavesForMyRank = myLeaves.size();
       
         //
         // Determine partition extents for my rank
@@ -881,7 +893,7 @@ void GenericIO::write()
         {
             //
             // Create Header info
-            addOctreeHeader( (uint64_t)((int)octreeLeafshuffle), (uint64_t)((int)simGlobalOctree), (uint64_t)numOctreeLevels, (uint64_t)numOctreeLeaves );
+            addOctreeHeader( (uint64_t)((int)octreeLeafshuffle), (uint64_t)numOctreeLevels, (uint64_t)numOctreeLeaves );
 
             //
             // Add Octree ranks
diff --git a/genericio/GenericIO.h b/genericio/GenericIO.h
index 27f2fea..8bfbd94 100644
--- a/genericio/GenericIO.h
+++ b/genericio/GenericIO.h
@@ -314,8 +314,8 @@ class GenericIO
     GenericIO(const MPI_Comm &C, const std::string &FN, unsigned FIOT = -1)
         : NElems(0), FileIOType(FIOT == (unsigned) - 1 ? DefaultFileIOType : FIOT),
           Partition(DefaultPartition), Comm(C), FileName(FN), Redistributing(false),
-          DisableCollErrChecking(false), SplitComm(MPI_COMM_NULL), hasOctree(false),
-          simGlobalOctree(true), octreeLeafshuffle(false), numOctreeLevels(0)
+          DisableCollErrChecking(false), SplitComm(MPI_COMM_NULL), 
+          hasOctree(false), octreeLeafshuffle(false), numOctreeLevels(0)
     {
         std::fill(PhysOrigin, PhysOrigin + 3, 0.0);
         std::fill(PhysScale,  PhysScale + 3, 0.0);
@@ -324,8 +324,7 @@ class GenericIO
     GenericIO(const std::string &FN, unsigned FIOT = -1)
         : NElems(0), FileIOType(FIOT == (unsigned) - 1 ? DefaultFileIOType : FIOT),
           Partition(DefaultPartition), FileName(FN), Redistributing(false),
-          DisableCollErrChecking(false), hasOctree(false),
-          simGlobalOctree(true), octreeLeafshuffle(false), numOctreeLevels(0)
+          DisableCollErrChecking(false), hasOctree(false), octreeLeafshuffle(false), numOctreeLevels(0)
     {
         std::fill(PhysOrigin, PhysOrigin + 3, 0.0);
         std::fill(PhysScale,  PhysScale + 3, 0.0);
@@ -380,18 +379,18 @@ class GenericIO
     }
 
 
-    void useOctree(bool _octreeLeafshuffle, int _numOctreeLevels, bool _simGlobalOctree)
+    void useOctree(int _numOctreeLevels, bool _octreeLeafshuffle=true)
     {
-        octreeLeafshuffle = _octreeLeafshuffle;
         numOctreeLevels = _numOctreeLevels;
-        _simGlobalOctree = simGlobalOctree;
+        octreeLeafshuffle = _octreeLeafshuffle;
         hasOctree = true;
+
+        //std::cout << "useOctree" << std::endl << std::endl;
     }
 
-    void addOctreeHeader(uint64_t _preShuffled, uint64_t _decompositionType, uint64_t _decompositionLevel, uint64_t _numEntries)
+    void addOctreeHeader(uint64_t _preShuffled, uint64_t _decompositionLevel, uint64_t _numEntries)
     {
         octreeData.preShuffled = _preShuffled; 
-        octreeData.decompositionType = _decompositionType;
         octreeData.decompositionLevel = _decompositionLevel;
         octreeData.numEntries = _numEntries;
     }
@@ -618,7 +617,6 @@ class GenericIO
     // Octree Data
     GIOOctree octreeData;
     bool hasOctree;         
-    bool simGlobalOctree;       // Octree for overall sim or based on rank 
     bool octreeLeafshuffle;     // shuffle paticles in a leaf
     int numOctreeLevels;        // num octree leaves = 8^numOctreeLevels
 
diff --git a/genericio/GenericIOSQLite.cxx b/genericio/GenericIOSQLite.cxx
index d258430..a0b8f5f 100644
--- a/genericio/GenericIOSQLite.cxx
+++ b/genericio/GenericIOSQLite.cxx
@@ -163,7 +163,6 @@ struct gio_vtab
     gio_vtab(const string &FN) : GIO(FN), FileName(FN)
     {
         memset(&vtab, 0, sizeof(sqlite3_vtab));
-
         GIO.openAndReadHeader(GenericIO::MismatchAllowed);
     }
 
diff --git a/genericio/utils/octree.hpp b/genericio/utils/octree.hpp
index 21b3c0e..b2a48ea 100755
--- a/genericio/utils/octree.hpp
+++ b/genericio/utils/octree.hpp
@@ -11,6 +11,7 @@
 #include <algorithm>
 #include <random>
 #include <stdio.h>
+//#include <mpi.h>
 
 #include "memory.h"
 #include "timer.h"
@@ -46,7 +47,6 @@ struct GIOOctreeRow
 struct GIOOctree
 {
     uint64_t preShuffled;			// particles shuffeed in leaves or not
-    uint64_t decompositionType;		// 1: global, 0: per rank
     uint64_t decompositionLevel;	// 
     uint64_t numEntries;			// # of octree leaves
     std::vector<GIOOctreeRow> rows;
@@ -56,7 +56,6 @@ struct GIOOctree
         std::stringstream ss;
 
         ss << serialize_uint64(preShuffled, bigEndian);
-        ss << serialize_uint64(decompositionType, bigEndian);
         ss << serialize_uint64(decompositionLevel, bigEndian);
         ss << serialize_uint64(numEntries, bigEndian);
 
@@ -82,7 +81,6 @@ struct GIOOctree
     void deserialize(char *serializedString, bool bigEndian)
     {
         preShuffled 		= deserialize_uint64(&serializedString[0],  bigEndian);
-        decompositionType  	= deserialize_uint64(&serializedString[8],  bigEndian);
         decompositionLevel 	= deserialize_uint64(&serializedString[16], bigEndian);
         numEntries 			= deserialize_uint64(&serializedString[24], bigEndian);
 		
@@ -183,7 +181,6 @@ struct GIOOctree
     void print()
     {
     	std::cout << "\nPre-Shuffled (0=No, 1=Yes): " << preShuffled << std::endl;
-    	std::cout << "Decomposition Type (0=Per Rank, 1=Sim): " << decompositionType << std::endl;
     	std::cout << "Decomposition Level: " << decompositionLevel << std::endl;
     	std::cout << "Num Entries: " << numEntries << std::endl;
 
@@ -212,19 +209,33 @@ struct PartitionExtents
 
 	PartitionExtents(){};
 	PartitionExtents(float _extents[6]){ for (int i=0; i<6; i++) extents[i]=_extents[i]; }
-};
 
+	void print()
+	{ 
+		std::cout << extents[0] << " - " << extents[1] << ", " 
+			      << extents[2] << " - " << extents[3] << ", " 
+			      << extents[4] << " - " << extents[5] << std::endl; 
+	}
+};
 
+struct Leaves
+{
+	std::vector<int> leafId;
+};
 
 class Octree
 {
-	float extents[6];
-	float rankExtents[6];
-	int numLevels;
+	float extents[6];		// Extents of the HACC sim
+	int maxSimExtents[3];	// border of the sim, usually 256
 
-	std::vector<uintptr_t> octreeLevels;				// stores the real nodes
+	int filePartition[3];	// Decomposition on the sim
+	int numLevels;			// number of octree levels
 
-	void chopVolume(float rootExtents[6], int _numLevels, std::list<PartitionExtents> &partitions);
+	std::vector<Leaves> rankLeaf;	// Specify which leaves are in each rank
+
+	float rankExtents[6];	// extents of the current rank ???
+
+	void chopVolume(float rootExtents[6], int _numLevels, int partitions[3], std::list<PartitionExtents> & partitionList);
 
 	std::stringstream log;
 	
@@ -236,13 +247,15 @@ class Octree
 	Octree(int _numLevels, float _extents[6]):numLevels(_numLevels){ for (int i=0; i<6; i++) extents[i] = _extents[i]; };
 	~Octree(){};
 	
-	void init(int _numLevels, float _extents[6]);
+	void init(int _numLevels, float _extents[6], int xDiv, int yDiv, int zDiv);
 	void buildOctree();
 
-	int getNumNodes(){ return (int) (pow(8.0f,numLevels)); }
+
+	int getNumNodes(){ return octreePartitions.size(); }
 	int getLeafIndex(float pos[3]);
 	void getLeafExtents(int leafId, float extents[6]);
 	void setRankExtents(float _rankExtents[6]){ for (int i=0;i<6;i++) rankExtents[i]=_rankExtents[i]; }
+	std::vector<int> getLeaves(int rank){ return rankLeaf[rank].leafId; }
 
 	std::string getPartitions();
 	void displayPartitions();
@@ -256,25 +269,51 @@ class Octree
 	template <typename T> std::vector<uint64_t> findLeaf(T inputArrayX[], T inputArrayY[], T inputArrayZ[], size_t numElements, int numPartitions, float partitionExtents[], std::vector<int> &partitionPosition);
 };
 
-inline void Octree::init(int _numLevels, float _extents[6])
+
+inline void Octree::init(int _numLevels, float _extents[6], int xDiv, int yDiv, int zDiv)
 {
 	numLevels = _numLevels;
 
 	for (int i=0; i<6; i++) 
 		extents[i] = _extents[i];
+
+	filePartition[0] = xDiv;
+	filePartition[1] = yDiv;
+	filePartition[2] = zDiv;
+
+	maxSimExtents[0] = (int)( _extents[1] + 0.49);		// x
+	maxSimExtents[1] = (int)( _extents[3] + 0.49);		// y
+	maxSimExtents[2] = (int)( _extents[5] + 0.49);		// z
 }
 
 
 inline void Octree::buildOctree()
 {
 	std::list<PartitionExtents> _octreePartitions;
-	chopVolume(extents, numLevels, _octreePartitions);
+	chopVolume(extents, numLevels, filePartition, _octreePartitions);
 
 	octreePartitions.resize( _octreePartitions.size() );
 	std::copy(_octreePartitions.begin(), _octreePartitions.end(), octreePartitions.begin());
+
+
+	if (myRank == 0)
+	{
+		std::cout << "Octree partitions: \n";
+		displayPartitions();
+
+
+		for (int i=0; i<rankLeaf.size(); i++)
+		{
+			std::cout << "Rank: " << i << std::endl;
+			for (int l=0; l<rankLeaf[i].leafId.size(); l++)
+				std::cout << rankLeaf[i].leafId[l] << ", ";
+			std::cout << "\n";
+		}
+	}
 }
 
 
+
 template <typename T> 
 inline bool Octree::checkPosition(float extents[], T _x, T _y, T _z)
 {
@@ -360,8 +399,6 @@ inline void Octree::reorganizeArray(int numPartitions, std::vector<uint64_t>part
   partitionOffsetMem.stop();
 
 
-	
-
 	// Partition count
   currentPartitionCountMem.start();
 	std::vector<int> currentPartitionCount;
@@ -524,106 +561,192 @@ inline std::vector<uint64_t> Octree::findLeaf(T inputArrayX[], T inputArrayY[],
 }
 
 
-
-inline void Octree::chopVolume(float rootExtents[6], int _numLevels, std::list<PartitionExtents> & partitionList)
+inline void Octree::chopVolume(float rootExtents[6], int _numLevels, int partitions[3], std::list<PartitionExtents> & partitionList)
 {
 	Timer clock;
 	clock.start();
 
-	//std::cout << "rootExtents: " << rootExtents[0] << ", " << rootExtents[1] << "   " << rootExtents[2] << ", " << rootExtents[3] << "   "  << rootExtents[4] << ", " << rootExtents[5] << std::endl;
-	PartitionExtents temp(rootExtents);				// Set the first partition as root 
+	//
+	// Set the first partition as root 
+	int numOctreePartitions = 1;
+	PartitionExtents temp(rootExtents);				
 	partitionList.push_back(temp);
 
-	PartitionExtents firstHalf, secondHalf;
+	// Set leaves
+	rankLeaf.resize(1);
+	rankLeaf[0].leafId.push_back(0);
 
+	if (_numLevels == 0)
+		return;
 
-	int splittingAxis = 0;								// start with x-axis
-	int numDesiredBlocks = (int) pow(8.0f, _numLevels);	// Compute number of splits needed based on levels
-	int numBlocks = 1;
 
+	//
+	// Set the second partition as rank extents in file
 
-	while (numBlocks < numDesiredBlocks)
-	{
-		int numCurrentBlocks = partitionList.size();
+	// Remove first partition
+	partitionList.pop_front();
+	numOctreePartitions = 0;
 
-		for (int i=0; i<numCurrentBlocks; i++)
-		{
-			temp = partitionList.front();
-			partitionList.pop_front();
+	// Get extensts of the file
+	float xExtents = rootExtents[1]-rootExtents[0];
+	float yExtents = rootExtents[3]-rootExtents[2];
+	float zExtents = rootExtents[5]-rootExtents[4];
 
-			// std::cout << "\t" << temp.extents[0] << ", " <<  temp.extents[1] << "   "
-			// 		  << temp.extents[2] << ", " <<  temp.extents[3] << "   "
-			// 		  << temp.extents[4] << ", " <<  temp.extents[5] << std::endl;
 
-			if (splittingAxis == 0)			// x-axis
+	// Create partitions
+	for (int x_axis=0; x_axis<partitions[0]; x_axis++)
+		for (int y_axis=0; y_axis<partitions[1]; y_axis++)
+			for (int z_axis=0; z_axis<partitions[2]; z_axis++)
 			{
-				firstHalf.extents[0] =  temp.extents[0];
-				firstHalf.extents[1] = (temp.extents[0] + temp.extents[1])/2;
+				float currentPartition[6];
+
+				currentPartition[0] = xExtents/partitions[0] * x_axis;
+				currentPartition[1] = currentPartition[0] + xExtents/partitions[0];
 
-				secondHalf.extents[0] = (temp.extents[0] + temp.extents[1])/2;
-				secondHalf.extents[1] =  temp.extents[1];
+				currentPartition[2] = yExtents/partitions[1] * y_axis;
+				currentPartition[3] = currentPartition[2] + yExtents/partitions[1];
 
+				currentPartition[4] = zExtents/partitions[2] * z_axis;
+				currentPartition[5] = currentPartition[4] + zExtents/partitions[2];
 
-				firstHalf.extents[2] = secondHalf.extents[2] = temp.extents[2];
-				firstHalf.extents[3] = secondHalf.extents[3] = temp.extents[3];
+				PartitionExtents tempRank(currentPartition);
+				partitionList.push_back(tempRank);
 
-				firstHalf.extents[4] = secondHalf.extents[4] = temp.extents[4];
-				firstHalf.extents[5] = secondHalf.extents[5] = temp.extents[5];
+				numOctreePartitions++;
 			}
-			else
-				if (splittingAxis == 1)		// y-axis
-				{
-					firstHalf.extents[0] = secondHalf.extents[0] = temp.extents[0];
-					firstHalf.extents[1] = secondHalf.extents[1] = temp.extents[1];
 
 
-					firstHalf.extents[2] =  temp.extents[2];
-					firstHalf.extents[3] = (temp.extents[2] + temp.extents[3])/2;
+	// Set leaves
+	rankLeaf.clear();
+	rankLeaf.resize(numOctreePartitions);
+	for (int i=0; i<numOctreePartitions; i++)
+		rankLeaf[i].leafId.push_back(i);
+
+	if (_numLevels == 1)
+		return;
+
+
+
+	//
+	// Now start diving the ranks
+	int _numRanks = numOctreePartitions;
+
+	// Copy data from current partition list to rank list
+	std::list<PartitionExtents> rankList;
+	for (int r=0; r<_numRanks; r++)
+	{
+		temp = partitionList.front();
+		rankList.push_back(temp);
+		partitionList.pop_front();
+	}
+
+
+	// Set leaves
+	rankLeaf.clear();
+	rankLeaf.resize(_numRanks);
+
+
+	// Partitions
+	numOctreePartitions = 0;
+	for (int r=0; r<_numRanks; r++)
+	{
+		// Get current root we are partitioning
+		PartitionExtents currentRoot = rankList.front();
+		rankList.pop_front();
+
+
+		// Initialize rank with current partition
+		std::list<PartitionExtents> currentPatitionList;
+		currentPatitionList.push_back(currentRoot);
+
+
+		//
+		//  Stat
+		PartitionExtents firstHalf, secondHalf;
+
+		int splittingAxis = 0;									// start with x-axis
+		int numDesiredBlocks = (int) pow(8.0f, _numLevels-1);	// Compute number of splits needed based on levels
+		int numBlocks = 1;
+
+		while (numBlocks < numDesiredBlocks)
+		{
+			int numCurrentBlocks = currentPatitionList.size();
+
+			for (int i=0; i<numCurrentBlocks; i++)
+			{
+				temp = currentPatitionList.front();
+				currentPatitionList.pop_front();
+
+				if (splittingAxis == 0)			// x-axis
+				{
+					firstHalf.extents[0] =  temp.extents[0];
+					firstHalf.extents[1] = (temp.extents[0] + temp.extents[1])/2;
+
+					secondHalf.extents[0] = (temp.extents[0] + temp.extents[1])/2;
+					secondHalf.extents[1] =  temp.extents[1];
 
-					secondHalf.extents[2] = (temp.extents[2] + temp.extents[3])/2;
-					secondHalf.extents[3] =  temp.extents[3];
 
+					firstHalf.extents[2] = secondHalf.extents[2] = temp.extents[2];
+					firstHalf.extents[3] = secondHalf.extents[3] = temp.extents[3];
 
 					firstHalf.extents[4] = secondHalf.extents[4] = temp.extents[4];
 					firstHalf.extents[5] = secondHalf.extents[5] = temp.extents[5];
 				}
 				else
-					if (splittingAxis == 2)	// z-axis
+					if (splittingAxis == 1)		// y-axis
 					{
 						firstHalf.extents[0] = secondHalf.extents[0] = temp.extents[0];
 						firstHalf.extents[1] = secondHalf.extents[1] = temp.extents[1];
 
-						firstHalf.extents[2] = secondHalf.extents[2] = temp.extents[2];
-						firstHalf.extents[3] = secondHalf.extents[3] = temp.extents[3];
 
+						firstHalf.extents[2] =  temp.extents[2];
+						firstHalf.extents[3] = (temp.extents[2] + temp.extents[3])/2;
 
-						firstHalf.extents[4] =  temp.extents[4];
-						firstHalf.extents[5] = (temp.extents[4] + temp.extents[5])/2;
+						secondHalf.extents[2] = (temp.extents[2] + temp.extents[3])/2;
+						secondHalf.extents[3] =  temp.extents[3];
 
-						secondHalf.extents[4] = (temp.extents[4] + temp.extents[5])/2;
-						secondHalf.extents[5] =  temp.extents[5];
+
+						firstHalf.extents[4] = secondHalf.extents[4] = temp.extents[4];
+						firstHalf.extents[5] = secondHalf.extents[5] = temp.extents[5];
 					}
+					else
+						if (splittingAxis == 2)	// z-axis
+						{
+							firstHalf.extents[0] = secondHalf.extents[0] = temp.extents[0];
+							firstHalf.extents[1] = secondHalf.extents[1] = temp.extents[1];
+
+							firstHalf.extents[2] = secondHalf.extents[2] = temp.extents[2];
+							firstHalf.extents[3] = secondHalf.extents[3] = temp.extents[3];
 
-			partitionList.push_back(firstHalf);
-			partitionList.push_back(secondHalf);
-		
 
-		// std::cout << "\t\t" << firstHalf.extents[0] << ", " <<  firstHalf.extents[1] << "   "
-		// 		  << firstHalf.extents[2] << ", " <<  firstHalf.extents[3] << "   "
-		// 		  << firstHalf.extents[4] << ", " <<  firstHalf.extents[5] << std::endl;
+							firstHalf.extents[4] =  temp.extents[4];
+							firstHalf.extents[5] = (temp.extents[4] + temp.extents[5])/2;
+
+							secondHalf.extents[4] = (temp.extents[4] + temp.extents[5])/2;
+							secondHalf.extents[5] =  temp.extents[5];
+						}
+
+				currentPatitionList.push_back(firstHalf);
+				currentPatitionList.push_back(secondHalf);
+			}
 
-		// std::cout << "\t\t" << secondHalf.extents[0] << ", " <<  secondHalf.extents[1] << "   "
-		// 		  << secondHalf.extents[2] << ", " <<  secondHalf.extents[3] << "   "
-		// 		  << secondHalf.extents[4] << ", " <<  secondHalf.extents[5] << std::endl << std::endl;
+			// cycle axis
+			splittingAxis++;
+			if (splittingAxis == 3)
+				splittingAxis = 0;
 
+			numBlocks = currentPatitionList.size();
 		}
 
-		// cycle axis
-		splittingAxis++;
-		if (splittingAxis == 3)
-			splittingAxis = 0;
 
-		numBlocks = partitionList.size();
+		// Fill partion list with items from this rank
+		for (auto it=currentPatitionList.begin(); it!=currentPatitionList.end(); ++it)
+		{
+			rankLeaf[r].leafId.push_back( partitionList.size() );
+
+			partitionList.push_back( *it );
+			numOctreePartitions++;
+		}
 	}
 
 	clock.stop();
@@ -661,85 +784,27 @@ inline void Octree::getLeafExtents( int leafId, float _extents[6])
 		_extents[i] = octreePartitions[leafId].extents[i];
 }
 
+
 inline int Octree::getLeafIndex(float pos[3])
 {
-	Timer clock;
-	clock.start();
-
-    //extents
-	float xDiv = (pos[0]-extents[0])/(extents[1]-extents[0]);
-	float yDiv = (pos[1]-extents[2])/(extents[3]-extents[2]);
-	float zDiv = (pos[2]-extents[4])/(extents[5]-extents[4]);
-
-	if (xDiv < 0 || xDiv > 1)
-		std::cout << "Error at pos " << pos[0] << ", " << pos[1] << ", " << pos[2] << std::endl;
-
-	if (yDiv < 0 || yDiv > 1)
-		std::cout << "Error at pos " << pos[0] << ", " << pos[1] << ", " << pos[2] << std::endl;
-
-	if (zDiv < 0 || zDiv > 1)
-		std::cout << "Error at pos " << pos[0] << ", " << pos[1] << ", " << pos[2] << std::endl;
-
-	std::vector<int> bitPosition;
-	float halfX, halfY, halfZ;
-	float sizeX, sizeY, sizeZ;
-
-	sizeX = sizeY = sizeZ = 0.25;
-	halfX = halfY = halfZ = 0.5;
-
-	for (int i=0; i<numLevels; i++)
-	{
-		// x-axis
-		if (xDiv < halfX)
-		{
-			halfX -= sizeX;
-			bitPosition.push_back(0);
-		}
-		else
-		{
-			halfX += sizeX;
-			bitPosition.push_back(1);
-		}
-
-		//y-axis
-		if (yDiv < halfY)
-		{
-			halfY -= sizeY;
-			bitPosition.push_back(0);
-		}
-		else
-		{
-			halfY += sizeY;
-			bitPosition.push_back(1);
-		}
-
-		//z-axis
-		if (zDiv < halfZ)
-		{
-			halfZ -= sizeZ;
-			bitPosition.push_back(0);
-		}
-		else
-		{
-			halfZ += sizeZ;
-			bitPosition.push_back(1);
-		}
-		sizeX /= 2;
-		sizeY /= 2;
-		sizeZ /= 2;
+	float x = pos[0];
+	float y = pos[1];
+	float z = pos[2];
+	for (int i=0; i<octreePartitions.size(); i++)
+	{		
+
+		// Nothing should be at 256, but some are!!!
+		if (x >= maxSimExtents[0]) x = (float)maxSimExtents[0] - 0.00001;
+		if (y >= maxSimExtents[1]) y = (float)maxSimExtents[1] - 0.00001;
+		if (z >= maxSimExtents[2]) z = (float)maxSimExtents[2] - 0.00001;
+
+		if (x >= extents[0] && x<extents[1])
+			if (y >= extents[2] && y<extents[3])
+				if (z >= extents[4] && z<extents[5])
+					return i;	
 	}
 
-	int index = 0;
-	for (int i=0; i<bitPosition.size(); i++)
-		index += pow(2, bitPosition.size()-1-i) * bitPosition[i];
-		
-
-	if (index < 0 || index >= pow(8.0,numLevels))
-		std::cout << "Index " << index << " Error at pos " << pos[0] << ", " << pos[1] << ", " << pos[2] << std::endl;
-	return index;
-
-	clock.stop();
-	log << "Octree::getLeafIndex took " << clock.getDuration() << " s " << std::endl;
+	return -1;
 }
 
 
